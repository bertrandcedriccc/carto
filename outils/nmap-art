#!/usr/bin/env python2
#

from threading import BoundedSemaphore, Thread

from time import sleep
from random import random
from datetime import datetime
import os
import sys
import getopt
import signal
import time
import random

import pexpect
import time
import datetime
from re import *
from socket import *

cdeb = "["
cfin = "[0m"

random.seed()
randomid = random.randint(42,65000)


#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# Declaration de chemin d'acces de chaque outil
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#os.popen(cmd)
#nmap_cmd_tcp = "nmap -Pn -O -A -sC -p1-65535 -sV -v -T4 -max-rtt-timeout 20 --host-timeout 3600 --max-scan-delay 20 --max-retries 1 --osscan-guess --osscan-limit "
#tcp_options = "-r --traceroute --script "default,safe" -sS -sV -PN -O --osscan-guess -p1-65535"
tcp_options = " --max-rtt-timeout 20 --host-timeout 2400 --max-scan-delay 20 --max-retries 1 -sT -T4 -PN -p1-65535"
#tcp_options = " -max-rtt-timeout 20 --host-timeout 2400 --max-scan-delay 20 --max-retries 1 -sT -T4 -PN -p80,443,8080,8443"
#common_tcp_options = " -max-rtt-timeout 20 --host-timeout 3600 --max-scan-delay 20 --max-retries 1 -T4 -sT -PN --top-ports 5000"
common_tcp_options = " --max-rtt-timeout 20 --host-timeout 2400 --max-scan-delay 20 --max-retries 1 -sT -T4 -PN -p1-65535"
udp_options = "-r -sU -PN"

if os.path.exists("/usr/sbin/ifconfig"):bin_ifconfig="/usr/sbin/ifconfig"
elif os.path.exists("/sbin/ifconfig") : bin_ifconfig = "/sbin/ifconfig"
else: bin_ifconfig = "/sbin/ifconfig"
if os.path.exists("/usr/bin/nmap"):bin_nmap="/usr/bin/nmap"
elif os.path.exists("/usr/bin/nmap") : bin_nmap = "/usr/bin/nmap"
else: bin_nmap = "/usr/bin/nmap"
if os.path.exists("/usr/bin/echo"):bin_echo="/usr/bin/echo"
elif os.path.exists("/bin/echo") : bin_echo = "/bin/echo"
else: bin_echo = "/bin/echo"


#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# Config Socket
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

host="localhost"
buffer="128"
port_hping="60003"
token_hping="512"
port_nmap=60002
#token=32
token=8
addr = (host,port_nmap)


input_file=datetime.datetime.now().strftime("/tmp/liste_%Y%d%m_%Hh%Mm%S")

global toolid
toolid=input_file

output_dir      = ""
#datetime.datetime.now().strftime("./resultats/%Y%d%m_%Hh%M")
jeton 		= BoundedSemaphore(token)
mk_liste	= True
xml_gen         = False
verbose		= True
verbose2	= False
verbose3	= False
#tooldir		= path
id_client	= ['libre']
nb_ip		= 0
iface           = ""

range_id = range(int(token+1))

for id in range_id:
   id_client.append('libre') 




#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# Classe Audit
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Audit(Thread):

        def __init__(self,_id,_ip,_exec_bin, jeton):
                Thread.__init__(self)
                self.id		= _id
		self.ip		= _ip
		self.exec_bin	= _exec_bin
		self.jeton = jeton
 
        def run(self):
		global nb_ip
		global randomid

		self.mkdir()
		self.date()

		if verbose : print cdeb+"32m > "+self.ip+" processing... "+cfin

                tcp_state="3"
                udp_state="3"
		#self.jeton.acquire()


		# nmap ------------------------------------
		if param_nmap_tcp_only == True:
			tcp_state="2"
                        UDPSock = socket(AF_INET,SOCK_DGRAM)
                        msg = str(self.id)+":"+self.ip+":"+toolid+":::"+tcp_state+":"+udp_state+":0:"+str(nb_ip)+":0:0:0:0:0:0:0:0:0:0:0:0"
                        UDPSock.sendto(msg,addr)

			s_ntcp = self.nmap_tcp(tcp_state,udp_state,"")

                        tcp_state="1"

        	        msg = str(self.id)+":"+self.ip+":"+toolid+":::"+tcp_state+":"+udp_state+":x:"+str(nb_ip)+":0:0:0:0:0:0:0:0:0:0:0:0"

		elif param_nmap_tcp_common == True:
                        udp_state="2"
                        UDPSock = socket(AF_INET,SOCK_DGRAM)
                        msg = str(self.id)+":"+self.ip+":"+toolid+":::"+tcp_state+":"+udp_state+":0:"+str(nb_ip)+":0:0:0:0:0:0:0:0:0:0:0:0"
                        UDPSock.sendto(msg,addr)

			s_ntcp = self.nmap_tcp(tcp_state,udp_state,"common")

                        udp_state="1"

                        msg = str(self.id)+":"+self.ip+":"+toolid+":::"+tcp_state+":"+udp_state+":x:"+str(nb_ip)+":0:0:0:0:0:0:0:0:0:0:0"

		elif param_nmap_udp_only == True:
                        udp_state="2"
                        UDPSock = socket(AF_INET,SOCK_DGRAM)
                        msg = str(self.id)+":"+self.ip+":"+toolid+":::"+tcp_state+":"+udp_state+":0:"+str(nb_ip)+":0:0:0:0:0:0:0:0:0:0:0:0"
                        UDPSock.sendto(msg,addr)

			s_nudp = self.nmap_udp(tcp_state,udp_state)

                        udp_state="1"

                        msg = str(self.id)+":"+self.ip+":"+toolid+":::"+tcp_state+":"+udp_state+":x:"+str(nb_ip)+":0:0:0:0:0:0:0:0:0:0:0"
		else:
			## SCAN TCP ###
                        tcp_state="2"
                        UDPSock = socket(AF_INET,SOCK_DGRAM)
                        msg = str(self.id)+":"+self.ip+":"+toolid+":::"+tcp_state+":"+udp_state+":0:"+str(nb_ip)+":0:0:0:0:0:0:0:0:0:0:0:0"
                        UDPSock.sendto(msg,addr)

			s_ntcp = self.nmap_tcp(tcp_state,udp_state)

                        tcp_state="1"
                        msg = str(self.id)+":"+self.ip+":"+toolid+":::"+tcp_state+":"+udp_state+":0:"+str(nb_ip)+":0:0:0:0:0:0:0:0:0:0:0:0"
                        UDPSock.sendto(msg,addr)

			## SCAN UDP ##
                        udp_state="2"
                        msg = str(self.id)+":"+self.ip+":"+toolid+":::"+tcp_state+":"+udp_state+":0:"+str(nb_ip)+":0:0:0:0:0:0:0:0:0:0:0:0"
                        UDPSock.sendto(msg,addr)

			s_nudp = self.nmap_udp(tcp_state,udp_state)

                        udp_state="1"

                        #UDPSock = socket(AF_INET,SOCK_DGRAM)
                        msg = str(self.id)+":"+self.ip+":"+toolid+":::"+tcp_state+":"+udp_state+":0:"+str(nb_ip)+":0:0:0:0:0:0:0:0:0:0:0:0"
#                        msg = str(self.id)+":"+self.ip+":"+toolid+":::1:1:ok:"+str(nb_ip)+":0:0:0:0:0:0:0:0:0:0:0"
#			UDPSock.close()

                nb_ip = nb_ip-1
                time = datetime.datetime.now().strftime("[%H:%M:%S] ")	
		if verbose : print cdeb+"32m > "+self.ip+" finished ! "+cfin
		print cdeb+"34m > "+str(time)+str(nb_ip)+" host remaining.. "+cfin

		cmd = bin_echo+" "+self.ip+" >> "+output_dir+"/ipdone_nmap-mt"
		os.popen(cmd,"r")
                msg = str(self.id)+":"+self.ip+":"+toolid+":::"+tcp_state+":"+udp_state+":x:"+str(nb_ip)+":0:0:0:0:0:0:0:0:0:0:0:0"
#		msg = str(self.id)+":"+self.ip+":"+toolid+":::1:1:ok:"+str(nb_ip)+":0:0:0:0:0:0:0:0:0:0:0"
                UDPSock.sendto(msg,addr)
                UDPSock.close()

                id_client[self.id] = "libre"

                self.jeton.release()

	def mkdir(self):
		if not os.path.isdir(output_dir):
			os.popen("mkdir "+output_dir,"r")
		if not os.path.isdir(output_dir+self.ip):
			os.popen("mkdir "+output_dir+"/"+self.ip,"r")
		
	def date(self): os.popen("date > "+output_dir+"/"+self.ip+"/date.txt","r")
	
	def nmap_tcp(self,tcp_st,udp_st,options):
		if options == "common" :
			cmd=bin_nmap+" "+common_tcp_options+" -oA "+output_dir+self.ip+"/nmapTCP "+self.ip+" #nmapartemis"+str(randomid) 
		else:
			cmd=bin_nmap+" "+tcp_options+" -oA "+output_dir+self.ip+"/nmapTCP "+self.ip+" #nmapartemis"+str(randomid) 
                if verbose : print cdeb+"31m  > "+self.ip+cfin+" \t"+cmd.split("#nmapartemis")[0]

		child = pexpect.spawn(cmd)
		child.expect ('Starting')
		child.sendline ('\n')

		pourcentage=""
		etat=""
		info=""
	
		while 1:
			sleep(2)		
		        try:
				child.expect ('\w+\r\n')
			        child.sendline ('\n')
	
				p = compile('\d{1,3}\.\d{1,2}%')
				perc = p.findall(child.before)
	
	                        p = compile('^([A-Za-z]+)')
	                        st = p.findall(child.before)
	
	                        for sample in perc: pourcentage = sample
	                        for sample in st  : etat = sample
	
				if (len(etat) > 0) and (len(pourcentage) > 0): 
					info = etat+" "+pourcentage
				else:	info = etat
				
	                        UDPSock = socket(AF_INET,SOCK_DGRAM)
	                        msg = str(self.id)+":"+self.ip+":"+toolid+":::"+tcp_st+":"+udp_st+":0:"+str(nb_ip)+":"+info+":0:0:0:0:0:0:0:0:0:0:0:0"
	                        UDPSock.sendto(msg,addr)
	
	                        if ("Nmap done" in child.before):
		                        UDPSock = socket(AF_INET,SOCK_DGRAM)
					msg = str(self.id)+":"+self.ip+":"+toolid+":::"+tcp_st+":"+udp_st+":0:"+str(nb_ip)+":Finished:0:0:0:0:0:0:0:0:0:0:0:0"
	
	#	                        msg = str(self.id)+":"+self.ip+":"+toolid+":::2:0:0:"+str(nb_ip)+":"+info+":Finished:0:0:0:0:0:0:0:0:0:0"
		                        UDPSock.sendto(msg,addr)
					break
			except pexpect.TIMEOUT:
				if verbose: print "pexpect timeout"

#		if verbose : print cdeb+"31m  > "+self.ip+cfin+" \t"+cmd.split("2>>")[0]

		# Suppression des balises <taskprogress/>
		cmd="xmlstarlet ed -d taskprogress "+output_dir+self.ip+"/nmapTCP.xml > "+output_dir+self.ip+"/nmapTCP.xml.clean"
		os.popen(cmd,"r")

		cmd="rm "+output_dir+self.ip+"/nmapTCP.xml"
		os.popen(cmd,"r")

		cmd="mv "+output_dir+self.ip+"/nmapTCP.xml.clean "+output_dir+self.ip+"/nmapTCP.xml"
		os.popen(cmd,"r")

		return "1:"



	def nmap_udp(self,tcp_st,udp_st):
		cmd=bin_nmap+" "+udp_options+" -oA "+output_dir+self.ip+"/nmapUDP "+self.ip+" #nmapartemis"+str(randomid) 

		if verbose : print cdeb+"31m  > "+self.ip+cfin+" \t"+cmd.split("#nmapartemis")[0]
		child = pexpect.spawn(cmd)
		child.expect ('Starting')
		child.sendline ('\n')
		
		pourcentage=""
		etat=""
		info=""
		
		while 1:
			sleep(1)
			child.expect ('\w+\r\n')
			child.sendline ('\n')

			p = compile('\d{1,3}\.\d{1,2}%')
			perc = p.findall(child.before)

			p = compile('^([A-Za-z]+)')
			st = p.findall(child.before)
			
			for sample in perc: pourcentage = sample
			for sample in st  : etat = sample
			
			if (len(etat) > 0) and (len(pourcentage) > 0):
				info = etat+" "+pourcentage
			else:   info = etat

			UDPSock = socket(AF_INET,SOCK_DGRAM)
			msg = str(self.id)+":"+self.ip+":"+toolid+":::"+tcp_st+":"+udp_st+":0:"+str(nb_ip)+":"+info+":0:0:0:0:0:0:0:0:0:0:0:0"
         #msg = str(self.id)+":"+self.ip+":"+toolid+":::0:2:0:"+str(nb_ip)+":"+info+":0:0:0:0:0:0:0:0:0:0:0:0"
			UDPSock.sendto(msg,addr)

			if ("Nmap done" in child.before):
				UDPSock = socket(AF_INET,SOCK_DGRAM)
				msg = str(self.id)+":"+self.ip+":"+toolid+":::"+tcp_st+":"+udp_st+":0:"+str(nb_ip)+":Finished:0:0:0:0:0:0:0:0:0:0:0:0"
				#msg = str(self.id)+":"+self.ip+":"+toolid+":::0:2:0:"+str(nb_ip)+":0:Finished:0:0:0:0:0:0:0:0:0:0"
				UDPSock.sendto(msg,addr)
				break

		#if verbose : print cdeb+"31m  > "+self.ip+cfin+" \t"+cmd.split("2>>")[0]

		# Suppression des balises <taskprogress/>
		cmd="xmlstarlet ed -d taskprogress "+output_dir+self.ip+"/nmapUDP.xml > "+output_dir+self.ip+"/nmapUDP.xml.clean"
		os.popen(cmd,"r")

		cmd="rm "+output_dir+self.ip+"/nmapUDP.xml"
		os.popen(cmd,"r")

		cmd="mv "+output_dir+self.ip+"/nmapUDP.xml.clean "+output_dir+self.ip+"/nmapUDP.xml"
		os.popen(cmd,"r")

		return "1:"

#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# Fonction check_bin                                                                      /!\ FONCTION BLOQUANTE /!\
# Cette fonction verifie l'existance des outils, soit la validite du PATH
# Elle renvoie un tableau de ce type [nmap, amap, hping, netwox, dig, ike] contenant:
#    - "True"  lorsque l'on peut executer la commande (PATH ok)
#    - "False" lorsque l'on ne peut executer la commande (PATH ko)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

def check_bin():

	exec_nmap	= True
	error		= False

        if not os.path.isfile(bin_nmap):
                exec_nmap = False
                print cdeb+"31merreur : nmap is not present or wrong PATH, please check the var bin_nmap"+cfin
                print cdeb+"31m         nmap PATH is "+bin_nmap+""+cfin
	if error:
		print ""
		print "-> Tool(s) not found will be skipped, are you sure to continue? (y/n)"
		if sys.stdin.read(1)!='y': sys.exit(2)
	
	exec_bin = [exec_nmap]
	return exec_bin


#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# Fonction check_dir
# Cette fonction verifie si le repertoire de sortie est conforme
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

def check_dir(out_dir):
	if (out_dir[-1:] != '/'): out_dir = out_dir+"/"
	return(out_dir)

#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# Fonction ifconfig
# Creation d'un fichier avec le ifconfig
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

def ifconfig():
	cmd = bin_ifconfig+" > "+output_dir+"/ifconfig.txt"
	os.popen(cmd,"r")

	os.popen("date > "+output_dir+"/ipdone_nmap-mt","r")

#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# Fonction usage
# Cette fonction permet l'affichage de l'aide
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

def usage():
    from textwrap import dedent
    usage = """\
    
    
    Usage: %s [options] -o /output/dir/ <address>
      -h or --help         show help

      -i                   interface (eth0)

      --v1                 verbose mode
      --v2                 verbose mode ++

      --nmap_tcp_only
      --nmap_udp_only

      --nmap_tcp_common

      -o                   /the/path/ of the output directory
                           Current directory is not allowed
      
      -f                   <filename> to specify a "IP" list
      <address>            one address : 192.168.100.1
                            or a range : 192.168.100.1-192.168.100.50
		  
    """
    sys.stderr.write(dedent(usage % "nmap-mt"))



#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# MAIN
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

args = sys.argv
args.remove(args[0])

try:
        optlist, args = getopt.getopt(args, 'hVGf:o:i:',['v1','v2','v3','version','help','nmap_tcp_common','nmap_tcp_only','nmap_udp_only'])
except getopt.GetoptError, e:
        sys.stderr.write("%s\n" % e)
        sys.stderr.write("use -h or --help for help\n")
	sys.exit(2)


#print len(args)

param_nmap_tcp_only     = False
param_nmap_udp_only     = False
param_nmap_tcp_common   = False
mk_liste 		= True

# traitement des options
for o,c in optlist:
        if   o == "-h" or o == "--help":
	     usage()
             sys.exit(0)
	elif o == "-f":
	     input_file = c
	     mk_liste = False
        elif o == "-i":
             iface = c
	elif o == "-o":
	     output_dir = os.path.abspath(c)+os.sep
        elif o == "--v1":
	     verbose = True
	elif o == "--v2":
	     verbose = True
	     verbose2 = True
        elif o == "--nmap_tcp_only":
             param_nmap_tcp_only = True
        elif o == "--nmap_tcp_common":
             param_nmap_tcp_common = True
        elif o == "--nmap_udp_only":
             param_nmap_udp_only = True

if (len(output_dir)<3):
        usage()
        sys.exit(2)

if ((len(args)<1) and (mk_liste)):
	usage()
	sys.exit(2)

if mk_liste: create_list()

ifconfig()
exec_bin = check_bin()
output_dir = check_dir(output_dir)

#Watcher()
child = os.fork()
if child != 0:
	try:
		os.wait()
	except KeyboardInterrupt:
		# I put the capital B in KeyBoardInterrupt so I can
		# tell when the Watcher gets the SIGINT
		#print 'SIGINT'
		try:
			cmd = "ps ax | grep nmap | grep '#nmapartemis"+str(randomid)+"' | awk {'print $1'}"
			ids = os.popen(cmd)
			pids = ids.readlines()
			os.kill(child, signal.SIGKILL)
			for pid in pids:
				os.kill(int(pid), signal.SIGKILL)
			
		except OSError: pass
		sys.exit()

else:
	
	time = datetime.datetime.now().strftime("[%H:%M:%S]")
	print cdeb+"35m > "+str(time)+" Processing ... "+cfin
	
	if not os.path.isdir(output_dir):
	  os.popen("mkdir "+output_dir,"r")
	
	cmd = os.popen("grep . "+input_file+" | wc -l " )
	nb_ip = int(cmd.readline()[:-1])
	
	file = open(input_file,'r')
	lines = file.readlines()
	
	j = 0
	
	if iface != "" : 
		tcp_options="-e "+iface+" "+tcp_options
		udp_options="-e "+iface+" "+udp_options
	
	threads = []

	# Reinitialisation rapide du client
	k=1
	while k < token+1:
                UDPSock = socket(AF_INET,SOCK_DGRAM)
		msg = str(k)+":               ::::3:3::0:   :0:0:0:0:0:0:0:0:0:0:0:0"
        	UDPSock.sendto(msg,addr)
		k=k+1
		UDPSock.close()
	# fin

	
	for ip_line in lines:
		if (ip_line != "\n"):
			ip = ip_line.split('\n')[0]
	
			if verbose2 : print cdeb+"30m   - "+ip+" is waiting for token..."+cfin
                        jeton.acquire()
			while 1:
#					sleep(0.0001)
					j = j + 1
					if j == token+1: j = 1 
					if id_client[j] == "libre":
						id_client[j] = "occup"
						ident = j
						break

			auditip = Audit(ident,ip,exec_bin,jeton)
			threads.append(auditip)
			auditip.start()
	
	for auditip in threads:
		auditip.join()	
	file.close


